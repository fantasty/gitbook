# 面试题：重建二叉树

```cpp
struct BinaryTreeNode{
    int                value;
    BinaryTreeNode*    left;
    BinartTreeNode*    right;
}
```

```cpp
void ConstructTree(int *preOrder, int *inOrder, int length)
{
    if (preOrder == NULL || inOrder == NULL || l********ength <= 0)
        return;
    ConstructCore(preOrder, preOrder+length-1, inOrder, inOrder+length-1)
}

BinaryTreeNode* ConstructCore(int *preOrderStart, int *preOrderEnd, int *inOrderStart, int *inOrderEnd)
{
    int rootValue = preOrderStart[0];
    BinaryTreeNode* root = new BinaryTreeNode();
    root->value = rootValue;
    root->left = root->right = NULL;
    
    if (preOrderStart == preOrderEnd)
    {
        if(inOrderStart == preOrderEnd && *preOrderStart == *inOrderStart)
            return root;
        throw std::exception("Invalid Input");
    }

    int *inOrderRoot = *inOrderStart;
    while(inOrderRoot <= inOrderEnd && *inOrderRoot != rootValue)
        ++inOrderRoot;
    if (inOrderRoot == inOrderEnd && *inOrderRoot != rootValue)``
        throw std::exception("Invalid Input");
    
    int leftLength = inOrderRoot - inOrderStart;
    int *preOrderLeftEnd = preOrderStart + leftLength;
    if (leftLength > 0)
        root->left = ConstructCore(preOrderStart + 1, preOrderLeftEnd, inOrderStart, inOrderRoot - 1);
    if (leftLength < preOrderEnd - preOrderStart)
        root->right = ConstructCore(preOrderLeft + 1, preOrderEnd, inOrderRoot + 1, inOrderEnd);
    return root;   
}
```

# 树的子结构

题目：输入两个二叉树A,B，判断B是不是A的子结构

```cpp

//进一步判断是否是子树
bool DoesTree1HasSubTree2 (BinaryTreeNode* head1, BinaryTreeNode* head2)
{
    if (head2 == NULL)
        return true;
    if (head1 == NULL)
        return false;
    if (head1->value != head2->value)
        return false;
    
    return DoesTree1HasSubTree2 (head1->pLeft, head2->pLeft) && 
            DoesTree1HasSubTree2 (head1->pRight, head2->pRight);
}


//在A中找是否有B的头节点
bool hasSubTree (BinaryTreeNode* head1, BinaryTreeNode* head2)
{
    bool result = false;
    
    if(head1 != NULL && head2 != NULL)
    { 
        if (head1->value == head2->value)
            result = DoesTree1HasSubTree2(head1, head2);
        if (!result)
            result = hasSubTree(head1->pLeft, head2);
        if(!result)
            result = hasSubTree(head1->pRight, head2);
    }
    return result;
}

```





















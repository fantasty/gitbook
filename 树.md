# 面试题：重建二叉树

```cpp
struct BinaryTreeNode{
    int                value;
    BinaryTreeNode*    left;
    BinartTreeNode*    right;
}
```

```cpp
void ConstructTree(int *preOrder, int *inOrder, int length)
{
    if (preOrder == NULL || inOrder == NULL || l********ength <= 0)
        return;
    ConstructCore(preOrder, preOrder+length-1, inOrder, inOrder+length-1)
}

BinaryTreeNode* ConstructCore(int *preOrderStart, int *preOrderEnd, int *inOrderStart, int *inOrderEnd)
{
    int rootValue = preOrderStart[0];
    BinaryTreeNode* root = new BinaryTreeNode();
    root->value = rootValue;
    root->left = root->right = NULL;
    
    if (preOrderStart == preOrderEnd)
    {
        if(inOrderStart == preOrderEnd && *preOrderStart == *inOrderStart)
            return root;
        throw std::exception("Invalid Input");
    }

    int *inOrderRoot = *inOrderStart;
    while(inOrderRoot <= inOrderEnd && *inOrderRoot != rootValue)
        ++inOrderRoot;
    if (inOrderRoot == inOrderEnd && *inOrderRoot != rootValue)
        throw std::exception("Invalid Input");
    
    int leftLength = inOrderRoot - inOrderStart;
    int *preOrderLeftEnd = preOrderStart + leftLength;
    if (leftLength > 0)
        root->left = ConstructCore(preOrderStart + 1, preOrderLeftEnd, inOrderStart, inOrderRoot - 1);
    if (leftLength < preOrderEnd - preOrderStart)
        root->right = ConstructCore(preOrderLeft + 1, preOrderEnd, inOrderRoot + 1, inOrderEnd);
    return root;   
}
```

# 树的子结构

题目：输入两个二叉树A,B，判断B是不是A的子结构

```cpp

//进一步判断是否是子树
bool DoesTree1HasSubTree2 (BinaryTreeNode* head1, BinaryTreeNode* head2)
{
    if (head2 == NULL)
        return true;
    if (head1 == NULL)
        return false;
    if (head1->value != head2->value)
        return false;
    
    return DoesTree1HasSubTree2 (head1->pLeft, head2->pLeft) && 
            DoesTree1HasSubTree2 (head1->pRight, head2->pRight);
}


//在A中找是否有B的头节点
bool hasSubTree (BinaryTreeNode* head1, BinaryTreeNode* head2)
{
    bool result = false;
    
    if(head1 != NULL && head2 != NULL)
    { 
        if (head1->value == head2->value)
            result = DoesTree1HasSubTree2(head1, head2);
        if (!result)
            result = hasSubTree(head1->pLeft, head2);
        if(!result)
            result = hasSubTree(head1->pRight, head2);
    }
    return result;
}

```

#树的镜像

思路：前序遍历树的每个节点，如果遍历到的节点有子节点，就交换它的子节点，当变换完所有非叶子节点后，得到树的镜像


```cpp

void TreeMirror(BinaryTreeNode *root)
{
    if (root == NULL || (root->pLeft == NULL && root->pRight == NULL))
        return;
    BinaryTreeNode *temp = root->pLeft;
    root->pLeft = root->pRight;
    root->pRight = temp;
    
    if (root->pLeft != NULL)
        TreeMirror(root->pLeft);
    if (root->pRight != NULL)
        TreeMirror(root->pRight);
}

```

# 广度优先遍历打印二叉树

题目：从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序进行打印。

思路：先取根节点，将根节点的两个左右子结点保存到容器中，再将根结点进行打印。取出容器中第一个节点在取两个子结点放入容器。再一次打印。采用先进先出的顺序，这个数据容器应该是一个队列。

```cpp

void fromToptoBottom(BinaryTreeNode *root)
{
    if (root == NULL)
        return;
    
    std::deque<BinaryTreeNode*> dequeTreeNode;
    dequeTreeNode.push_back(root);
    
    while (dequeTreeNode.size())
    {
        BinaryTreeNode *pNode = dequeTreeNode.front();
        dequeTreeNode.pop_front();
        printf("%d",pNode->value);
        if (pNode->pLeft)
            dequeTreeNode.push_back(pNode->pLeft);
        if (pNode->pRight)
            dequeTreeNode.push_back(pNode->pRight);
    }
}

```

# 二叉树的后序遍历

题目：输入一个整数数组，判断该数组是不是某二叉树的后续遍历的结果。如果是返回true，不是返回false。假设输入的数组的任意两个数字不同。

思路：数组最后一个元素是根节点，数组中前面的数字都比根节点小，属于左子树，后面的数字都比根节点大，属于右子树

```cpp

bool VerifyNumbersofBST(int *numbers, int length)
{
    if (numbers == NULL || length <= 0)
        return false;
    //二叉树中左子树的节点的值均小于根节点
    int root = numbers[length - 1];
    int i = 0;
    for (; i < length - 1; i++)
    {
        if (numbers[i] > root)
            break;
    }
    //二叉树中右子树的节点的值均大于根节点
    int j = i;
    for (; j < length - 1; j++)
    {
        if (numbers[j] < root)
            return false;
    }
    //判断左子树是否为二叉搜索树
    bool left = true;
    if (i > 0)
        left = VerifyNumbersofBST(numbers, i + 1);
    //判断右子树是不是二叉搜索树
    bool right = true;
    if (i < length - 1)
        right = VerifyNumbersofBST(numbers + i, length - i - 1);

    return (left && right);

}



```
























---

# 数值的整数次方

题目：实现函数double Power\(double base, int exponent\),求base的exponent次方。不得使用库函数，不考虑大数

思路：考虑指数为负数, 底数为零的情况。倒数分母不能为零

```cpp
bool b_InvalidInput = false;
double Power(double base, int exponent)
{
    b_InvalidInput = false;
    if(equal(base, 0.0) && exponent < 0)
    {
        b_InvalidInput = true;
        return 0.0;
    }

    unsigned int absExponent = (unsigned int)abs(exponent);
    if (exponent < 0)
        absExponent = -exponent;
    double result = PowerUnsignedExponent(base, -exponent);
    if (exponent < 0)
        result = 1.0 / result;

    return result;
}

double PowerUnsignedExponent(double base, unisgned int exponent)
{
    if (exponent == 0)
        return 0.0;
    if (exponent == 1)
        return base;

    double result = PowerUnsignedExponent(base, exponent >> 2);
    if (exponent && 0x1 == 1)
        result = base * result;

    return result;
}

bool equal (double num1, double num2)
{
    if ((num1 - num2 < 0.00000001） && (num2 - num1 > -0.000000001))
        return true;
    return false;
}
```

---

# 打印1到最大的n位数

题目：输入数字n，按顺序打印1到最大的n为十进制数，比如输入3，则打印输出1，2，3...999

思路1:模拟加法

```cpp
#include <iostream>
#include <cstring>
#include <stdio.h>

using namespace std;

//对999...999加1时，才会在第一个字符(下标为0)的基础上产生进位，其他情况不会在第一个字符上进位。所以当第一个字符产生进位，表明这已经是
//最大的n位数，此时Increment返回true
bool Increment(char *number)
{
    bool isOverFlow = false;
    int nStepOver = 0;
    int nLength = strlen (number);
    for (int i = nLength - 1; i >= 0; i--)
    {
         int nSum = number[i] - '0' + nStepOver;
         if (i == nLength - 1)
             nSum++;
         if (nSum >= 10)
         {
             if (i == 0)
                 isOverFlow = true;
             else
             {
                 nSum -= 10;
                 nStepOver = 1;
                 number[i] = '0' + nSum;
             }
         }
         else
         {
             number[i] = '0' + nSum;
             break;
         }
    }

    return isOverFlow;
}

//只有在碰到第一个非零的字符才开始打印，直到字符串结尾
void PrintNumber(char *number)
{
    bool isBeginning0 = true;
    int nLength = strlen(number);
    for (int i = 0; i < nLength; ++i)
    {
        if(isBeginning0 && number[i] != '0')
        {
            isBeginning0 = false;
        }
        if (!isBeginning0)
            printf("%c",number[i]);
    }
    printf("\t");
}

void print1ToMaxofNDigits(unsigned int n)
{
    char *number = new char[n+1];
    memset(number, '0', n);
    number[n] = '\0';

    while (!Increment(number))
    {
        PrintNumber(number);
    }

    delete []number;
}

int main()
{
    print1ToMaxofNDigits (5);
    return 0;
}
```

思路2:全排列

```cpp

void print1ToMaxofNDigits(int n)
{
    char *numbers = new char[n+1];
    memset(numbers, 0, n);
    numbers[n] = '\0';
    for (int i = 0; i < 10; i++)
    {
        numbers[0] = i + '0';
        Print1ToMaxofNDigitsRecursively(numbers, n, 0);
    }
}

void Print1ToMaxofNDigitsRecursively(char *numbers, int length, int index)
{
    if (index == length - 1)
    {
        PrintNumber(numbers);
        return;
    }
    for (int i = 0; i < 10; i++)
    {
        numbers[index + 1] = i + '0';
        Print1ToMaxofNDigitsRecursively(numbers, length, index + 1);
    }
}


```

# 二叉树中和为某一值的路径

题目：输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从根节点开始往下一直到叶节点所形成一条路径

思路：前序遍历访问某一节点时，把该节点添加到路径中，并累加节点的值，如果该节点为叶子节点并且路径中节点值的和刚好等于输入的整数，直接打印。如果当前节点不是叶子节点，则继续访问它的叶子节点。当前节点访问结束后，递归函数会自动回到它的父节点。因此在函数退出之前要在函数路径上删除当前节点并减去当前节点的值，以确保返回父节点时刚好是从根节点到父节点的路径。

```cpp
#include <vector>

struct BinaryTreeNode{
    int               value;
    BinaryTreeNode    *pLeft;
    BinaryTreeNode    *pRight;
};

void FindPath(BinaryTreeNode *root, int expectedNum, std::vector<int>& path, int &CurrentSum)
{
    CurrentSum = root->value;
    path.push_back (root->value);
    
    bool isLeaf = root->pLeft == NULL && root->pRight == NULL;
    //如果是叶子节点，并且路径上的节点和等于输入值
    //打印出路径
    if (CurrentSum == expectedNum && isLeaf)
    {
        printf ("a path is found:");
        std::vector<int>::iterator iter = path.begin ();
        for (; iter != path.end (); iter++)
            printf ("%d,", *iter);
        printf ("\n");
    }
    if (root->pLeft != NULL)
        FindPath (root->pLeft, expectedNum, path, CurrentSum);
    if (root->pRight != NULL)
        FindPath (root->pRight, expectedNum, path, CurrentSum);
    
    CurrentSum -= root->value;
    path.pop_back ();   
}

void FindPath(BinaryTreeNode *root, int expectedNum)
{
    if (root == NULL)
        return;
    
    std::vector<int> path;
    int currentSum = 0;
    FindPath(root, expectedNum, path, currentSum);
}


```



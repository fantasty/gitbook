# 旋转数组中最小的数字\(二分查找变体\)

题目：把一个数组最开始的若干个元素搬到数组末尾，我们称为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组中最小的元素。例如数组{3，4，5，1，2}为{1，2，3，4，5}的一个旋转，为该数组的最小值为1

思路：和二分查找一样，用两个指针指向数组的第一个元素和最后一个元素。按照旋转规则，第一个元素应该是大于或者等于最后一个元素\(有特例\)。接着查找数组中间的元素。如果位于前面的递增子数组，第一个指针指向中间元素。以此缩小范围。同样的如果位于后面的的递增子数组，第二个指针指向中间元素。最终第一个指针指向第一个递增数组的最后一个元素，第二个指针指向第二个递增子数组的第一个元素。即最终会指向两个相邻的元素，而第二个指针指向的元素为最小元素。这是循环结束条件

```cpp

int Min(int *numbers, int length)
{
    if (numbers == NULL || length <= 0)
        throw new std::exception("Invalid parameter");
    int index1 = 0;
    int index2 = length - 1;
    int indexMid = index1;
    while (numbers[index1] >= numbers[index2])
    {
        if(index2 - index1 == 1)
        {   
            indexMid = index2;     
            break;
        }

        indexMid = (index1 + index2) / 2;
        //如果下标为index1，index2，indexMid指向的三个数组相同，只能顺序查找
        if (numbers[index1] == numbers[indexMid] 
            && numbers[index1] == numbers[index2])
            return MinInorder(numbers, index1, index2);
        if (numbers[indexMid] >= numbers[index1])
            index1 = indexMid;
        else if (numbers[indexMid] <= numbers[index2])
            index2 = indexMid;
    }
    return numbers[indexMid];
}

int MinInorder(int *numbers, int index1, int index2)
{
    int result = numbers[index1];
    for (int i = index + 1; i < index2 + 1; i++)
    {
        if (numbers[i] < result)
            result = numbers[i];
    }
    return result;
}


```

# 二维数组的查找

题目：在一个二维数组中，每一行都是按照从左到右递增的顺序排序，每一列都是按照从上到下的顺序排序。请完成一个函数，输入一个数组和一个整数，判断数组中是否有该函数。

```cpp
bool Find(*matrix, int rows, int columns, int value)
{
    bool Found = false;
    if (matrix != NULL && rows > 0 && columns > 0)
    {    
        int row = 0;
        int column = columns - 1;
        while (row < rows && column > 0)
        {
            if (matrix[row * columns + column] == value)
            {
                Found = true;
                return Found;
            }
            else if (matrix[row * columns + column] > value)
                row++;
            else
               column--;
        }
    return Found;
}
```

# 两个有序数组合并\(从后往前\)

```c
void Merge(int *number1, int *number2, int num1_len, int num2_len)
{
    int indexNewLen = num1_len + num2_len - 1;
    int indexOriginalLen1 = num1_len - 1;
    int indexOriginalLen2 = num2_len - 1;
    while (indexOriginalLen1 >= 0 && indexNewLen > indexOriginalLen1)
    {
        if(number[indexOriginalLen2] > number[indexOriginal1])
            number[indexNewLen--] = number[indexOriginalLen2--];
        else
            number[indexNewLen--] = number[indexOriginalLen1--];
    }    
    while (indexOriginalLen2 > 0)
        number[indexNewLen--] = number[indexOriginalLen2--];
}    
















```

